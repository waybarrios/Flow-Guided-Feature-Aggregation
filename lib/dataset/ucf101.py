# --------------------------------------------------------# Deep Feature Flow# Copyright (c) 2017 Microsoft# Licensed under The MIT License [see LICENSE for details]# Written by Xizhou Zhu# --------------------------------------------------------"""ImageNet VID databaseThis class loads ground truth notations from standard ImageNet VID XML data formatsand transform them into IMDB format. Selective search is used for proposals, see roidbfunction. Results are written as the ImageNet VID format. Evaluation is based on mAPcriterion."""import cPickleimport pandas as pdimport cv2import osimport numpy as npfrom PIL import Imagefrom imdb_ucf101 import IMDBfrom imagenet_vid_eval import vid_evalfrom ds_utils import unique_boxes, filter_small_boxesclass UCF101(IMDB):    def __init__(self, root_path, dataset_path, traintestlist_path, result_path=None, split = '01'):        """        fill basic information to initialize imdb        """        super(UCF101, self).__init__('UCF101', root_path, dataset_path, traintestlist_path,                                          result_path, split)  # set self.name        self.root_path = root_path        self.data_path = dataset_path        self.traintestlist_path = traintestlist_path        self.split = split        self.classes = self.load_labels(os.path.join(traintestlist_path, 'classInd.txt'))        self.num_classes = len(self.classes)        self.load_image_set_index()        self.num_images = len(self.image_set_index)        print 'num_images', self.num_images    # load class names    def load_labels(self, label_csv_path):        data = pd.read_csv(label_csv_path, delimiter=' ', header=None)        labels = []        for i in range(data.shape[0]):            labels.append(data.iloc[i, data.columns.get_loc(1)])        return labels    def load_value_file(self, file_path):        """        used for load the frame number for a video        :param file_path: the file name        :return: frame number        by weik        """        with open(file_path, 'r') as input_file:            value = float(input_file.read().rstrip('\n\r'))        return value    def load_image_set_index(self, subset='train'):        """        load the video list and video label        annotate the video frame with the label of video        :param subset: train or test        :return: no return            self.image_set_list: name list of video            self.image_set_list_label: label list of video            self.image_set_index: name list of frame for all video, formatting as $video_name/$frame_name            self.frame_id: index list of frame for all video, starting from 0            self.image_set_label: the label for video frames            self.image_set_list_start_end: the start and end index of video using frame_id        by weik        """        """        find out which indexes correspond to given image set (train or test)        :return:        """        image_set_list_file = os.path.join(self.traintestlist_path, subset+'list' + self.split + '.txt')        assert os.path.exists(image_set_list_file), 'Path does not exist: {}'.format(image_set_list_file)        cache_file = os.path.join(self.cache_path, self.name + '_' + subset + '_' + self.split + '.pkl')        if os.path.exists(cache_file):            with open(cache_file, 'rb') as fid:                image_set_info = cPickle.load(fid)            print '{} image_set_info loaded from {}'.format(self.name, cache_file)            self.image_set_index = image_set_info['image_set_index']            self.frame_id = image_set_info['frame_id']            self.image_set_label = image_set_info['image_set_label']            self.image_set_list_start_end = image_set_info['image_set_list_start_end']            self.image_set_list = image_set_info['image_set_list']            self.image_set_list_label = image_set_info['image_set_list_label']            return        with open(image_set_list_file) as f:            lines = [x.strip().split(' ') for x in f.readlines()]        if len(lines[0]) == 2:            self.image_set_list = [x[0].split('.')[0] for x in lines]            self.image_set_list_label = [x[1] for x in lines]            image_set_index = []            frame_id = []            image_set_label = []            image_set_list_start_end = []            count = 0            for video_idx, video_name in enumerate(self.image_set_list):                n_frames_file_path = os.path.join(self.data_path, video_name, 'n_frames')                n_frames = int(self.load_value_file(n_frames_file_path))                for frame_idx in np.arange(1, n_frames+1):                    image_set_index.append(os.path.join(video_name, "image_{:05d}.jpg".format(frame_idx)))                    frame_id.append(count+frame_idx-1)                    image_set_label.append(self.image_set_list_label[video_idx])                image_set_list_start_end.append([count, count+n_frames-1])                count = count + n_frames            self.image_set_index = image_set_index            self.frame_id = frame_id            self.image_set_label = image_set_label            self.image_set_list_start_end = image_set_list_start_end        image_set_info = {}        image_set_info['image_set_index'] = self.image_set_index        image_set_info['frame_id'] = self.frame_id        image_set_info['image_set_label'] = self.image_set_label        image_set_info['image_set_list_start_end'] = self.image_set_list_start_end        image_set_info['image_set_list'] = self.image_set_list        image_set_info['image_set_list_label'] = self.image_set_list_label        with open(cache_file, 'wb') as fid:            cPickle.dump(image_set_info, fid, cPickle.HIGHEST_PROTOCOL)        print 'wrote image_set_info  to {}'.format(cache_file)    def image_path_from_index(self, index):        """        given image index, find out full path        :param index: index of a specific image        :return: full path of this image        by weik        """        image_file = os.path.join(self.data_path, index)        return image_file    def load_image_annotation(self, iindex):        """        for a given index, load image info        :param index: index of a specific image        :return: record['iamge', 'frame_id', 'label', 'flipped', 'width', 'height']        be weik        """        index = self.image_set_index[iindex]        roi_rec = dict()        roi_rec['image'] = self.image_path_from_index(index)        roi_rec['frame_id'] = self.frame_id[iindex]        roi_rec['label'] = self.image_set_label[iindex]        img = Image.open(roi_rec['image'])        roi_rec['height'] = float(img.height)        roi_rec['width'] = float(img.width)        roi_rec['flipped'] = False        return roi_rec    def load_video_annotation(self, iindex):        """        for a given index, load video information        :param index: index of a specific image        :return: record['iamges', 'label', 'length', 'flipped', 'width', 'height']        be weik        """        video_name = self.image_set_list[iindex]        start_id = self.image_set_list_start_end[iindex][0]        end_id = self.image_set_list_start_end[iindex][1]        roi_rec = dict()        roi_rec['images'] = [self.image_path_from_index(self.image_set_index[i]) for i in range(start_id, end_id+1)]        roi_rec['label'] = self.image_set_list_label[iindex]        roi_rec['length'] = end_id - start_id +1        img = Image.open(roi_rec['images'][0])        roi_rec['height'] = float(img.height)        roi_rec['width'] = float(img.width)        roi_rec['flipped'] = False        return roi_rec    def gt_db(self):        """        return ground truth video frame database        :return: imdb[image_index]['iamge', 'frame_id', 'label', 'flipped', 'width', 'height']        """        cache_file = os.path.join(self.cache_path, self.name + '_gt_db.pkl')        if os.path.exists(cache_file):            with open(cache_file, 'rb') as fid:                roidb = cPickle.load(fid)            print '{} gt db loaded from {}'.format(self.name, cache_file)            return roidb        gt_db = [self.load_image_annotation(index) for index in range(0, len(self.image_set_index))]        with open(cache_file, 'wb') as fid:            cPickle.dump(gt_db, fid, cPickle.HIGHEST_PROTOCOL)        print 'wrote gt roidb to {}'.format(cache_file)        return gt_db    def gt_vid_db(self):        """        return ground truth image regions database        :return: imdb[video_index]['iamges', 'label', 'flipped', 'width', 'height']        """        cache_file = os.path.join(self.cache_path, self.name + '_gt_vid_db.pkl')        if os.path.exists(cache_file):            with open(cache_file, 'rb') as fid:                roidb = cPickle.load(fid)            print '{} gt db loaded from {}'.format(self.name, cache_file)            return roidb        gt_db = [self.load_video_annotation(index) for index in range(0, len(self.image_set_list))]        with open(cache_file, 'wb') as fid:            cPickle.dump(gt_db, fid, cPickle.HIGHEST_PROTOCOL)        print 'wrote gt roidb to {}'.format(cache_file)        return gt_db